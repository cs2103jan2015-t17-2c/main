//@author: a0114130e



	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMAddTasks.h
	 */


#ifndef TMADDTASKS_H
#define TMADDTASKS_H

#include "TMCommand.h"

#include <iostream>

class TMAddTasks : public TMCommand {


public:
	TMAddTasks() {}

	void execute() {
		TMParser *parser = TMParser::getInstance(); 
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();

		TMTask task = parser->parseTaskInfo();
		TMTaskList taskList = taskListStates->getCurrentTaskList();
		std::ostringstream oss;
		int positionIndex;

		taskList.addTask(task);
		TaskType type = task.getTaskType();
		
		if (type != Invalid) {
			positionIndex = taskList.getPositionIndexFromTask(task);
			positionIndexes.push_back(positionIndex);
		}

		switch (type) {
		case WithStartDateTime:
			oss << STATUS_DISPLAY_NEW_INDEX << positionIndex << ADD_SDT_SUCCESS;
			break;

		case WithEndDateTime:
			oss << STATUS_DISPLAY_NEW_INDEX << positionIndex << ADD_EDT_SUCCESS;
			break;

		case WithPeriod:
			if (task.isClashed()) {
				oss << STATUS_DISPLAY_NEW_INDEX << positionIndex << CLASH_WARNING;
			} else {
				oss << STATUS_DISPLAY_NEW_INDEX << positionIndex << ADD_PERIOD_SUCCESS;
			}
			break;

		case Undated:
			oss << STATUS_DISPLAY_NEW_INDEX << positionIndex << ADD_UNDATED_SUCCESS;
			break;

		case Invalid:
			oss << ADD_INVALID;
			break;
		}

		outcome = oss.str();
		taskListStates->addNewState(taskList);
	
	}


};

#endif


	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMAddTasks.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMBlockTime.h
	 */


#ifndef TMBLOCKTIME_H
#define TMBLOCKTIME_H

#include "TMCommand.h"
#include "TaskChecker.h"


class TMBlockTime : public TMCommand {
	
public:

	void execute() {
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		TMParser *parser = TMParser::getInstance();
        TaskChecker *taskChecker = TaskChecker::getInstance();
		TMTaskList taskList = taskListStates->getCurrentTaskList();
		std::ostringstream ossValid, ossInvalid;
		int i = taskList.generateUniqueBatchNum();
        
        std::vector<TMTask> tasks = parser->parseMultipleTimingTaskInfo();
		std::vector<TMTask>::iterator iter;
		int numInvalid = 0;

		for (iter = tasks.begin(); iter != tasks.end(); ++iter) {
			TMTask task = *iter;
			if (task.getTaskType() != TaskType::Invalid) {
				task.setAsUnconfirmed();
				task.setUnconfirmedBatchNumber(i);
				taskList.addTask(task);
				int positionIndex = taskList.getPositionIndexFromTask(task);
				positionIndexes.push_back(positionIndex);
			} else {
				numInvalid++;
			}
		}
		
		if (positionIndexes.size() != 0) {
			std::vector<int>::iterator intIter;
			ossValid << STATUS_DISPLAY_INDEXES;
			for (intIter = positionIndexes.begin(); intIter != positionIndexes.end(); ++intIter) {
				ossValid << *intIter << " ";
			}
			ossValid << BLOCK_SUCCESS << std::endl;
		}

		if (numInvalid != 0) {
			ossInvalid << BLOCK_FAILURE << numInvalid;
		}

		outcome = ossValid.str() + ossInvalid.str();
		taskListStates->addNewState(taskList);
	}

};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMBlockTime.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMCommand.h
	 */

#pragma once
#ifndef TMCOMMAND_H
#define TMCOMMAND_H

#include <sstream>
#include "TMParser.h"
#include "TMTaskListStates.h"
#include "TMTaskList.h"
#include "TMTask.h"
#include "TMExecutor.h"

class TMCommand{
	
	public: 
	
	virtual void execute() = 0;

	std::string outcome;
	
	std::vector<int> positionIndexes;
	
	//Returns true if the user specifies repeated indexes to be manipulated.
	bool hasRepeatedIndexes(std::vector<int> indexes) {
		std::vector<int>::iterator iter1, iter2;
		
		for (iter1 = indexes.begin(); iter1 != indexes.end(); ++iter1) {
			int checkIndex = *iter1;
			for (iter2 = iter1 + 1; iter2 != indexes.end(); ++iter2) {
				if (*iter2 == checkIndex) {
					return true;
				}
			}
		}

		return false;
	}

	bool hasValidIndexes() {
		return (positionIndexes.size() != 0);
	}

	bool hasValidIndexes(int numberOfTasksManipulated) {
		return (numberOfTasksManipulated != 0);
	}

	bool hasInvalidIndexes(std::string invalidIndexesString) {
		return (invalidIndexesString.size() != 0);
	}

	void updatePositionIndexes(std::vector<int>& indexes, int deletedIndex) {
		std::vector<int>::iterator iter;
		for (iter = indexes.begin(); iter != indexes.end(); ++iter) {
			if (*iter > deletedIndex) {
				(*iter)--;
			}
		}
	}

	void handleRepeatedIndexes() {
		outcome = WARNING_REPEATED_INDEXES_SPECIFIED;
	}
};

#endif

	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMCommand.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMCommandCreator.h
	 */


#ifndef TMCOMMANDCREATOR_H
#define TMCOMMANDCREATOR_H

#include "TMCommand.h"
#include "TMParser.h"
#include "TMAddTasks.h"
#include "TMDeleteTasks.h"
#include "TMEditTask.h"
#include "TMSearchKeyword.h"
#include "TMSaveAt.h"
#include "TMBlockTime.h"
#include "TMConfirmTasks.h"
#include "TMDoneAllToday.h"
#include "TMCompleteTasks.h"
#include "TMUncompleteTasks.h"
#include "TMUndo.h"
#include "TMRedo.h"
#include "TMInvalidCommand.h"

class TMCommandCreator {
public:

	TMCommand* createNewCommandObj(TMParser::CommandTypes command) {
		TMCommand *newCmdPtr;
		switch (command) {
		case TMParser::CommandTypes::Add:
			newCmdPtr = new TMAddTasks();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::Delete:
			newCmdPtr = new TMDeleteTasks();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::Edit:
			newCmdPtr = new TMEditTask();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::SearchKeyword:
			newCmdPtr = new TMSearchKeyword();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::SaveAt:
			newCmdPtr = new TMSaveAt();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::Block:
			newCmdPtr = new TMBlockTime();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::Confirm:
			newCmdPtr = new TMConfirmTasks();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::Complete: 
			newCmdPtr = new TMCompleteTasks();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::CompleteAllToday:
			newCmdPtr = new TMDoneAllToday();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::Incomplete:
			newCmdPtr = new TMUncompleteTasks();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::Undo: 
			newCmdPtr = new TMUndo();
			return newCmdPtr;
			break;

		case TMParser::CommandTypes::Redo:
			newCmdPtr = new TMRedo();
			return newCmdPtr;
			break;

		default:
			newCmdPtr = new TMInvalidCommand();
			return newCmdPtr;
			break;


		}
	}
};

#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMCommandCreator.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMCompleteTasks.h
	 */

#ifndef TMCOMPLETETASKS_H
#define TMCOMPLETETASKS_H

#include "TMCommand.h"

class TMCompleteTasks : public TMCommand {

public:
	TMCompleteTasks() {}
	void execute() {
		TMParser *parser = TMParser::getInstance(); 
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		TMTaskList taskList = taskListStates->getCurrentTaskList();

		std::vector<int> completeIndexes = parser->parseTaskPositionNo();
		std::vector<int>::iterator intIter;
		std::ostringstream ossValid, ossInvalid;
		int numArchived = 0;

		if (hasRepeatedIndexes(completeIndexes)) {
			handleRepeatedIndexes();
			return;
		}

		for (intIter = completeIndexes.begin(); intIter != completeIndexes.end(); ) {
			if (!taskList.isValidPositionIndex(*intIter) || taskList.isInArchived(*intIter)) {
				ossInvalid << *intIter << " ";
				intIter = completeIndexes.erase(intIter);
			} else {
				++intIter;
			}
		}

		for (intIter = completeIndexes.begin(); intIter != completeIndexes.end(); ++intIter) {
			taskList.archiveOneTask(*intIter);
			updatePositionIndexes(completeIndexes, *intIter);
			numArchived++;

		}
		
		if (hasValidIndexes(numArchived)) {
			ossValid << numArchived << ARCHIVE_SUCCESS << '\n';
		}

		if (hasInvalidIndexes(ossInvalid.str())) {
			ossInvalid << STATUS_DISPLAY_INVALID_INDEXES;
		}

		outcome = ossValid.str() + ossInvalid.str();
		taskListStates->addNewState(taskList);
	}
};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMCompleteTasks.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMConfirmTasks.h
	 */

#ifndef TMCONFIRMTASKS_H
#define TMCONFIRMTASKS_H


#include "TMCommand.h"

class TMConfirmTasks : public TMCommand {
public: 
	void execute() {
		TMParser *parser = TMParser::getInstance(); 
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		TMTaskList taskList = taskListStates->getCurrentTaskList();
		
		std::vector<int> confirmedTasksIndexes = parser->parseTaskPositionNo();
		std::vector<int>::iterator intIter;
		std::vector<int>::iterator resultsIter;
		std::vector<int> batchNumbers;
		std::vector<TMTask> toBeAdded;
		std::vector<TMTask>::iterator taskIter;
		std::ostringstream ossValid, ossInvalid;

		if (hasRepeatedIndexes(confirmedTasksIndexes)) {
			handleRepeatedIndexes();
			return;
		}

		for (intIter = confirmedTasksIndexes.begin(); intIter != confirmedTasksIndexes.end(); ) {
			
			if (!taskList.isValidPositionIndex(*intIter)) {
				ossInvalid << *intIter << " ";
				intIter = confirmedTasksIndexes.erase(intIter);
			} else {
				TMTask task = taskList.getTaskFromPositionIndex(*intIter);
				if (task.isConfirmed()) {
					ossInvalid << *intIter << " ";
					intIter = confirmedTasksIndexes.erase(intIter);
				} else {
					++intIter;
				}
			}
		}


		//Creating new confirmed tasks and storing the batch numbers of confirmed tasks into a vector
		for (intIter = confirmedTasksIndexes.begin(); intIter != confirmedTasksIndexes.end(); ++intIter) {
			TMTask task = taskList.getTaskFromPositionIndex(*intIter);
			int batchNum = task.getUnconfirmedBatchNumber();
			batchNumbers.push_back(batchNum);
			
			task.setAsConfirmed();
			task.setUnconfirmedBatchNumber(0);
			toBeAdded.push_back(task);
		}

		//Removing tasks sharing similar batch numbers
		for (intIter = batchNumbers.begin(); intIter != batchNumbers.end(); ++intIter) {
			std::vector<int> results;
			results = taskList.searchUnconfirmedBatchNum(*intIter);
			for (resultsIter = results.begin(); resultsIter != results.end(); ++resultsIter) {
				taskList.removeTask(*resultsIter);
				updatePositionIndexes(results, *resultsIter);
			}
		}

		//Adding confirmed tasks
		for (taskIter = toBeAdded.begin(); taskIter != toBeAdded.end(); ++taskIter) {
			TMTask task = *taskIter;
			taskList.addTask(task);
			int positionIndex = taskList.getPositionIndexFromTask(task);
			positionIndexes.push_back(positionIndex);
		}

		if (hasValidIndexes()) {
			ossValid << STATUS_DISPLAY_INDEXES;
			for (intIter = positionIndexes.begin(); intIter != positionIndexes.end(); ++intIter) {
				ossValid << *intIter << " ";
			}
			ossValid << CONFIRM_SUCCESS << '\n';
		}

		if (hasInvalidIndexes(ossInvalid.str())) {
			ossInvalid << STATUS_DISPLAY_INVALID_INDEXES; 
		}

		outcome = ossValid.str() + ossInvalid.str();
		taskListStates->addNewState(taskList);
	}

};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMConfirmTasks.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMConstants.h
	 */

static const std::string STATUS_DISPLAY_INDEXES = "Tasks ";
static const std::string STATUS_DISPLAY_INVALID_INDEXES = " is an/are invalid position index(es).";
static const std::string STATUS_DISPLAY_NEW_INDEX = "New task ";
static const std::string ADD_SDT_SUCCESS = " (with start date and time) successfully added.";
static const std::string ADD_EDT_SUCCESS = " (with end date and time/deadline) successfully added.";
static const std::string ADD_PERIOD_SUCCESS = " (with period) successfully added.";
static const std::string ADD_UNDATED_SUCCESS = " (undated) successfully added.";
static const std::string ADD_INVALID = "The task you have specified has invalid component(s). Please specify a valid task.";
static const std::string CLASH_WARNING = " has clash(es) with tasks on hand.\nTasks involved have been highlighted in blue.";
static const std::string BLOCK_SUCCESS = " have been blocked.";
static const std::string BLOCK_FAILURE = "Number of tasks with invalid timings: ";
static const std::string ARCHIVE_SUCCESS = " task(s) successfully marked as completed and archived.";
static const std::string CONFIRM_SUCCESS = " is/are confirmed.";
static const std::string DELETE_SUCCESS = " task(s) successfully deleted.";
static const std::string EDIT_SUCCESS = "Successfully edited task.";
static const std::string INVALID_COMMAND_PROMPT = "The command you have entered is invalid, please enter a valid one.";
static const std::string CURRENT_DIRECTORY_NAME = "Current file directory is now at: ";
static const std::string CURRENT_FILE_NAME = "File name: ";
static const std::string INVAILD_DIRECTORY_SPECIFIED = "The directory you have specified is invalid";
static const std::string SEARCH_CONCLUSION_KEYWORD_PART1 = "Number of tasks containing the keyword <";
static const std::string SEARCH_CONCLUSION_KEYWORD_PART2 = "> is: ";
static const std::string UNCOMPLETE_SUCCESS =" tasks successfully marked as uncomplete.";
static const std::string UNDO_SUCCESS = "Undo last action successfully.";
static const std::string UNDO_FAILURE = "Initial state of the system is reached. Unable to undo.";
static const std::string REDO_SUCCESS = "Redo successfully.";
static const std::string REDO_FAILURE = "Latest state of the system is reached. Unable to redo.";
static const std::string WARNING_REPEATED_INDEXES_SPECIFIED = "Please do not specify an index more than once.";
static const std::string NO_INDEX_OR_DETAILS_SPECIFIED = "Please enter an index or the updated task details.";

static const std::string DEFAULT_REFERENCE_FILENAME = "TimeMaster.txt";
static const std::string DATED_TASK_DISPLAY_FORMAT = "<Task Type> <Task Description> <Start Date> <Start Time> <End Date> <End Time> <Completion> <Clash> <Confirmation> <Unconfirmed Batch Number>";
static const std::string UNDATED_TASK_DISPLAY_FORMAT = "<Task Type> <Task Description> <Completion>";
static const std::string DATED_HEADER = "Number of dated tasks: ";
static const std::string UNDATED_HEADER = "Number of undated tasks: ";
static const std::string ARCHIVED_HEADER = "Number of completed/archived tasks: ";
static const std::string USER_INFO_TIMEMASTER_FILE = "This file directs the program where to load existing data from. Please do not delete.";

#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMConstants.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMDeleteTasks.h
	 */

#ifndef TMDELETETASKS_H
#define TMDELETETASKS_H

#include "TMCommand.h"

class TMDeleteTasks : public TMCommand {

public:
	TMDeleteTasks() {}

	void execute() {
		TMParser *parser = TMParser::getInstance(); 
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		TMTaskList taskList = taskListStates->getCurrentTaskList();
		
		std::vector<int> deleteIndexes = parser->parseTaskPositionNo();
		std::vector <int>::iterator intIter;
		std::ostringstream ossValid, ossInvalid;
		int numDeleted = 0;
		
		if (hasRepeatedIndexes(deleteIndexes)) {
			handleRepeatedIndexes();
			return;
		}

		for (intIter = deleteIndexes.begin(); intIter != deleteIndexes.end(); ) {
			if (!taskList.isValidPositionIndex(*intIter)) {
				ossInvalid << *intIter << " ";
				intIter = deleteIndexes.erase(intIter);
			} else {
				++intIter;
			}
		}
		

		for (intIter = deleteIndexes.begin(); intIter != deleteIndexes.end(); ++intIter) {
			taskList.removeTask(*intIter);
			numDeleted++;
			updatePositionIndexes(deleteIndexes, *intIter);
		}
		
		if (hasValidIndexes(numDeleted)) {
			ossValid << numDeleted << DELETE_SUCCESS << '\n';
		}

		if (hasInvalidIndexes(ossInvalid.str())) {
			ossInvalid << STATUS_DISPLAY_INVALID_INDEXES;
		}

		outcome = ossValid.str() + ossInvalid.str();
		taskListStates->addNewState(taskList);
		
	}


};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMDeleteTasks.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMDoneAllToday.h
	 */

#ifndef TMDONEALLTODAY_H
#define TMDONEALLTODAY_H

#include "TMCommand.h"

class TMDoneAllToday : public TMCommand {

public:

	void execute() {
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		TMTaskList taskList = taskListStates->getCurrentTaskList();

		boost::gregorian::date dateToday =  boost::gregorian::day_clock::local_day();
		std::locale facet(std::locale::classic(), new boost::gregorian::date_facet("%d %b %Y"));
		std::ostringstream stream;
		stream.imbue(facet);
		std::string  strDateToday;
		stream << dateToday;
		strDateToday = stream.str();
		 

		int numDated = taskList.getDatedSize();
		std::vector<int> completeIndexes;
		std::ostringstream oss;

		for (int i = 1; i <= numDated; i++) {
			TMTask task = taskList.getTaskFromPositionIndex(i);
			if (task.getTaskTime().getEndDate() == strDateToday) {
				completeIndexes.push_back(i);
			}
		}

		std::vector<int>::iterator iter;
		int numArchived = 0;
		for (iter = completeIndexes.begin(); iter != completeIndexes.end(); ++iter) {
			taskList.archiveOneTask(*iter);
			numArchived++;
			updatePositionIndexes(completeIndexes, *iter);
		}

		oss << numArchived << ARCHIVE_SUCCESS;
		outcome = oss.str();
		taskListStates->addNewState(taskList);		
	}

};

#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMDoneAllToday.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMEditTask.h
	 */

#ifndef TMEDITTASK_H
#define TMEDITTASK_H

#include "TMCommand.h"
const std::string UPDATE_SUCCESS = "Task successfully edited.";

class TMEditTask : public TMCommand {

public:
	
	void execute() {
		TMParser *parser = TMParser::getInstance(); 
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		TMTaskList taskList = taskListStates->getCurrentTaskList();
		
		std::string strPositionIndex = parser->extractTokenAfterCommand();
		
		if (strPositionIndex != "") {
			int positionIndex = std::stoi(strPositionIndex);
			if (taskList.isValidPositionIndex(positionIndex)) {
				TMTask alteredTask = parser->parseTaskInfo();
				taskList.updateTask(positionIndex, alteredTask);
				int index = taskList.getPositionIndexFromTask(alteredTask);
				positionIndexes.push_back(index);
				outcome = EDIT_SUCCESS;
				taskListStates->addNewState(taskList);
			} else {
				std::ostringstream oss;
				oss << positionIndex << STATUS_DISPLAY_INVALID_INDEXES;
				outcome = oss.str();
			}
		} else {
			outcome = NO_INDEX_OR_DETAILS_SPECIFIED;
		}

	}

};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMEditTask.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMExecutor.cpp
	 */

#include "TMExecutor.h"
#include <string>

TMExecutor* TMExecutor::theOne;

TMExecutor::TMExecutor() {
	_currentDisplay= TMDisplay::Default;
}

TMExecutor* TMExecutor::getInstance() {
	if (theOne == NULL) {
		theOne = new TMExecutor();
	}
	return theOne; 
}

std::vector<std::string> TMExecutor::getUserInput() {
	return _unmanagedUserInput;
}

TMDisplay TMExecutor::getCurrentDisplay() {
	return _currentDisplay;
}

std::string TMExecutor::getResultOfExecution() {
	return _resultOfExecution;
}

std::vector<int> TMExecutor::getPositionIndexes() {
	return _positionIndexes;
}


void TMExecutor::setCurrentDisplay(TMDisplay display) {
	_currentDisplay = display;
}


bool TMExecutor::isDisplayChange(std::string userInput) {
	return (userInput.find("v") != std::string::npos);
}

TMDisplay TMExecutor::determineDisplayType(std::string userInput) {
	if (userInput == CMD_VIEW_DEFAULT || userInput == CMD_SHORTCUT_VIEW_DEFAULT) {
		return Default;
	}else if (userInput == CMD_VIEW_DEADLINE || userInput == CMD_SHORTCUT_VIEW_DEADLINE) {
		return DeadlineTasks;
	}else if (userInput == CMD_VIEW_UNDATED || userInput == CMD_SHORTCUT_VIEW_UNDATED) {
		return UndatedTasks;
	}else if (userInput == CMD_VIEW_ARCHIVED || userInput == CMD_SHORTCUT_VIEW_ARCHIVED) {
		return ArchivedTasks;
	}else if (userInput == CMD_VIEW_SEARCH || userInput == CMD_SHORTCUT_VIEW_SEARCH) {
		return SearchResults;
	} else {
		return Default;
	}
}

void TMExecutor::executeMain(std::string userInput) {

	TMParser *parser = TMParser::getInstance(); 
	TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
	TMTaskList taskList = taskListStates->getCurrentTaskList();
	TMCommandCreator cmdCreator;

	if (userInput != "") {
		_unmanagedUserInput.push_back(userInput);
		parser->initialize(userInput);
		std::string command = parser->extractCommand();
	
		if (isDisplayChange(command)) {
			_currentDisplay = determineDisplayType(command);
			_resultOfExecution = "";
		} else {
			TMParser::CommandTypes type = parser->determineCommandType(command);
			TMCommand* commandObjPtr = cmdCreator.createNewCommandObj(type);
			commandObjPtr->execute();
			_resultOfExecution = parser->getErrorMessage() + commandObjPtr->outcome;
			_positionIndexes = commandObjPtr->positionIndexes;
			if (type == TMParser::CommandTypes::SearchKeyword) {
				_positionIndexes = commandObjPtr->positionIndexes;
				_currentDisplay = SearchResults;
			} 
		}
	} else {
		TMCommand* commandObjPtr = cmdCreator.createNewCommandObj(TMParser::CommandTypes::Invalid);
		commandObjPtr->execute();
		_resultOfExecution = commandObjPtr->outcome;
	}

	taskList = taskListStates->getCurrentTaskList();
	taskList.writeToFile();

	return;
}

	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMExecutor.cpp





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMExecutor.h
	 */

#ifndef TMEXECUTOR_H
#define TMEXECUTOR_H

#include <sstream>
#include <cstdlib>
#include <vector>

#include "TMParser.h"
#include "TMTaskListStates.h"
#include "TMTaskList.h"
#include "TMCommandCreator.h"

enum TMDisplay {
    Default, DeadlineTasks, UndatedTasks, ArchivedTasks, SearchResults
	};


class TMExecutor {
	
private:
	
	std::vector<std::string> _unmanagedUserInput;
	TMExecutor::TMDisplay _currentDisplay;
	std::string _resultOfExecution;
	std::vector<int> _positionIndexes;
	
	static TMExecutor* theOne;
	TMExecutor();
	
public:
	
	static TMExecutor* getInstance();
	
	std::vector<std::string> getUserInput();
	TMDisplay getCurrentDisplay();
	std::string getResultOfExecution();
	std::vector<int> getPositionIndexes();
	
	void setCurrentDisplay(TMDisplay display);

	bool isDisplayChange(std::string userInput);
	TMDisplay determineDisplayType(std::string userInput);
	void executeMain(std::string userInput);
	

	
	
};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMExecutor.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMInvalidCommand.h
	 */

#ifndef TMINVALIDCOMMAND_H
#define TMINVALIDCOMMAND_H

#include "TMCommand.h"

class TMInvalidCommand : public TMCommand {
public:
	void execute() {
		outcome = INVALID_COMMAND_PROMPT;
	}

};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMInvalidCommand.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMRedo.h
	 */

#ifndef TMREDO_H
#define TMREDO_H

#include "TMCommand.h"

class TMRedo: public TMCommand {

public:
	void execute() {
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		if (taskListStates->progressCurrentState()) {
			outcome = REDO_SUCCESS;
		} else {
			outcome = REDO_FAILURE;
		} 
	}
};

#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMRedo.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMSaveAt.h
	 */

#ifndef TMSAVEAT_H
#define TMSAVEAT_H

#include "TMCommand.h"
#include <Windows.h>



class TMSaveAt : public TMCommand {
public:
	void execute() {
		TMParser *parser = TMParser::getInstance(); 
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		TMTaskList taskList = taskListStates->getCurrentTaskList();
		std::string directory = parser->parseDirectory();
		if (taskList.isValidDirectory(directory.c_str())) {
			taskList.setDirectoryName(directory);
			outcome = CURRENT_DIRECTORY_NAME + taskList.getDirectoryName() + '\n' + CURRENT_FILE_NAME + taskList.getFileName();
		} else {
			outcome = INVAILD_DIRECTORY_SPECIFIED;
		}
		
		taskListStates->addNewState(taskList);
	}

};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMSaveAt.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMSearchKeyword.h
	 */

#ifndef TMSEARCHKEYWORD_H
#define TMSEARCHKEYWORD_H

#include "TMCommand.h"


class TMSearchKeyword: public TMCommand {

public:
	void execute() {
		TMParser *parser = TMParser::getInstance(); 
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		TMTaskList taskList = taskListStates->getCurrentTaskList();

		positionIndexes = taskList.keywordSearch(parser->parseSearchKey());
		std::ostringstream oss;
		oss << SEARCH_CONCLUSION_KEYWORD_PART1 << parser->parseSearchKey() << SEARCH_CONCLUSION_KEYWORD_PART2 << positionIndexes.size();
		outcome = oss.str();
	}

};

#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMSearchKeyword.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMTaskList.cpp
	 */

#include "TMTaskList.h"

	TMTaskList::TMTaskList() {}

	//LOGIC FUNCTIONS//
	bool TMTaskList::areEquivalent(TMTask task1, TMTask task2) {
		if (task1.getTaskDescription() != task2.getTaskDescription()) {
			return false;
		}

		if (task1.getTaskTime().getStartDate() != task2.getTaskTime().getStartDate()) { //TO IMPLEMENT FUNCTION TO COMPARE TASKTIME
			return false;
		}
		if (task1.getTaskTime().getStartTime() != task2.getTaskTime().getStartTime()) { //TO IMPLEMENT FUNCTION TO COMPARE TASKTIME
			return false;
		}
		if (task1.getTaskTime().getEndDate() != task2.getTaskTime().getEndDate()) { //TO IMPLEMENT FUNCTION TO COMPARE TASKTIME
			return false;
		}
		if (task1.getTaskTime().getEndTime() != task2.getTaskTime().getEndTime()) { //TO IMPLEMENT FUNCTION TO COMPARE TASKTIME
			return false;
		}
		if (task1.isCompleted() != task2.isCompleted()) {
			return false;
		}

		if (task1.isConfirmed() != task2.isConfirmed()) {
			return false;
		}

		if (task1.getTaskType() != task2.getTaskType()) {
			return false;
		}
	
		return true;
	}

	bool TMTaskList::hasClash(TMTask task) { //REVISIT CODE AND CHECK FOR BOUNDARY VALUES
		std::vector<TMTask>::iterator iter;
		TMDateTime start = task.getTaskTime().getStartDateTime();
		
		for (iter = _dated.begin(); iter != _dated.end(); ++iter) {
			if (startsBeforeTime(*iter, start) && iter->getTaskType() == TaskType::WithPeriod) {
				if (isTwoClash(*iter, task)) {
					return true;
				}
			} else if (iter->getTaskType() == TaskType::WithPeriod) {
				if (isTwoClash(task, *iter)) {
					return true;
				}
			}
		}	
	return false;
	}

	bool TMTaskList::isTwoClash(TMTask task1, TMTask task2) { //REVISIT CODE
		return startsBeforeTime(task2, task1.getTaskTime().getEndDateTime());
		return true;
	}

	bool TMTaskList::startsBeforeTime(TMTask task, TMDateTime time) { //REVISIT CODE
		TMDateTime dateTime = task.getTaskTime().getStartDateTime();
		return isBefore(dateTime, time);
	} 

	bool TMTaskList::endsBeforeTime(TMTask task, TMDateTime time) {
		TMDateTime dateTime = task.getTaskTime().getEndDateTime();
		return isBefore(dateTime, time);
	} //REVISIT CODE

	bool TMTaskList::isBefore(TMDateTime time1, TMDateTime time2) { //REVISIT CODE
		if (time1.getBoostDate() > time2.getBoostDate()) {
			return false;
		} else if (time1.getBoostDate() == time2.getBoostDate()) {
			if (time1.getTime() >= time2.getTime()) {
				return false;
			}
		}

		return true;
	}

	bool TMTaskList::areEquivalentDateTime(TMDateTime time1, TMDateTime time2) {
		if (time1.getDate() != time2.getDate()) {
			return false;
		} else if (time1.getTime() != time2.getTime()) {
			return false;
		}

		return true;
	}

	bool TMTaskList::isValidPositionIndex(int positionIndex) {
		return (positionIndex > 0 && positionIndex <= int(_dated.size() + _undated.size() + _archived.size()));
	}

	bool TMTaskList::isInDated(int positionIndex) {
		return (positionIndex > 0 && positionIndex <= int(_dated.size()));
	}

	bool TMTaskList::isInUndated(int positionIndex) {
		return (positionIndex > int(_dated.size()) && positionIndex <= int(_dated.size() + _undated.size()));
	}

	bool TMTaskList::isInArchived(int positionIndex) {
		return (positionIndex > int(_dated.size() + _undated.size()) && positionIndex <= int(_dated.size() + _undated.size() + _archived.size()));
	}

	bool TMTaskList::isUniqueBatchNum(int i) {
		std::vector<TMTask>::iterator iter;
		for (iter = _dated.begin(); iter != _dated.end(); ++iter) {
			if (iter->getUnconfirmedBatchNumber() == i) {
				return false;
			}
		}
		return true;
	}

	void TMTaskList::setClashes(TMTask task, std::vector<TMTask>::iterator beginFrom) { //REVISIT CODE AND CHECK FOR BOUNDARY VALUES
		_clashes.clear();
		std::vector<TMTask>::iterator iter;
		TMDateTime start = task.getTaskTime().getStartDateTime();
		
		for (iter = beginFrom; iter != _dated.end(); ++iter) {
			TMTask &registeredTask = *iter;
			if (startsBeforeTime(registeredTask, start) && iter->getTaskType() == TaskType::WithPeriod) {
				if (isTwoClash(registeredTask, task)) {
					registeredTask.setAsClashed();
					_clashes.push_back(registeredTask);
				}
			} else if (isTwoClash(task, registeredTask) && iter->getTaskType() == TaskType::WithPeriod) {
					registeredTask.setAsClashed();
					_clashes.push_back(registeredTask);
			}
			
		}

	}

	void  TMTaskList::updateClashes(TMTask deleteTask) {
		setClashes(deleteTask, _dated.begin());
		std::vector<TMTask>::iterator iter;
		int i = 0;
		for (iter = _dated.begin(); iter != _dated.end() && i < int(_clashes.size()); ++iter) {
			if (areEquivalent(*iter, _clashes[i])) {
				iter->setAsUnclashed();
			}
			++i;
		}
	

		for (iter = _dated.begin(); iter != _dated.end(); ++iter) {
			TMTask &focusTask = *iter;
			if (iter+1 != _dated.end()) {
				setClashes(focusTask, iter+1);
				if (int(_clashes.size()) != 0) {
					iter->setAsClashed();
				}
			}
		}

	}

	std::vector<TMTask>::iterator TMTaskList::findEarliestTaskIter(std::vector<TMTask>::iterator unsortedStart) {
									TMTask earliestTask = *unsortedStart;
									std::vector<TMTask>::iterator earliestTaskIter;
									earliestTaskIter = unsortedStart;
									std::vector<TMTask>::iterator iter;
		
									for (iter = unsortedStart; iter != _dated.end(); ++iter) {
				
										if (startsBeforeTime(*iter, earliestTask.getTaskTime().getStartDateTime())) {
											earliestTask = *iter;
											earliestTaskIter = iter;
										} else if (areEquivalentDateTime(iter->getTaskTime().getStartDateTime(), earliestTask.getTaskTime().getStartDateTime())) {
											if ( isBefore(iter->getTaskTime().getEndDateTime(), earliestTask.getTaskTime().getEndDateTime()) ) {
												earliestTask = *iter;
												earliestTaskIter = iter;
											}
										}
									}

									return earliestTaskIter;
	}

	std::vector<TMTask>::iterator TMTaskList::findSmallestAlphaTaskIter(std::vector<TMTask>::iterator unsortedStart) {
									TMTask smallestAlphaTask = *unsortedStart;
									std::vector<TMTask>::iterator smallestAlphaTaskIter;
									smallestAlphaTaskIter = unsortedStart;
									std::vector<TMTask>::iterator iter;
		
									for (iter = unsortedStart; iter != _undated.end(); ++iter) {
										if (iter->getTaskDescription() < smallestAlphaTaskIter->getTaskDescription()) {
											smallestAlphaTask = *iter;
											smallestAlphaTaskIter = iter;
										}
									}

									return smallestAlphaTaskIter;
	}

	std::string TMTaskList::toLower(std::string toBeConverted) {
		std::string aCopy = toBeConverted;
		transform(aCopy.begin(), aCopy.end(), aCopy.begin(), ::tolower);
		return aCopy;
	}

	std::vector<int> TMTaskList::searchUnconfirmedBatchNum(int i) {
		std::vector<TMTask>::iterator iter;
		std::vector<int> results;

		for (iter = _dated.begin(); iter != _dated.end(); ++iter) {
			if (iter->getUnconfirmedBatchNumber() == i && !iter->isConfirmed()) {
				results.push_back(getPositionIndexFromTask(*iter));
			}
		}
		return results;
	}

	


	//GETTER FUNCTIONS//
	int TMTaskList::getPositionIndexFromTask(TMTask task) {
		std::vector<TMTask>::iterator iter;
		int positionIndex = 1;
		
		for (iter = _dated.begin(); iter != _dated.end(); ++iter) {
			if (areEquivalent(task, *iter)) {
				return positionIndex;
			}
			positionIndex++;
		}
		
		for (iter = _undated.begin(); iter != _undated.end(); ++iter) {
			if (areEquivalent(task, *iter)) {
				return positionIndex;
			}
			positionIndex++;
		}

		for (iter = _archived.begin(); iter != _archived.end(); ++iter) {
			if (areEquivalent(task, *iter)) {
				return positionIndex;
			}
			positionIndex++;
		}

		return 0;
	}	

	TMTask TMTaskList::getTaskFromPositionIndex(int positionIndex) {
		TMTaskTime taskTime;
		TMTask invalidTask("", taskTime, TaskType::Invalid);

		if (isInDated(positionIndex)) {
			return _dated[positionIndex - 1];
		}

		if (isInUndated(positionIndex)) {
			return _undated[positionIndex - int(_dated.size()) - 1];
		}

		if (isInArchived(positionIndex)) {
			return _archived[positionIndex - int(_dated.size()) - int(_undated.size()) - 1];
		}
		
		return invalidTask;
	}

	int TMTaskList::getDatedSize() {
		return _dated.size();
	}

	int TMTaskList::getUndatedSize() {
		return _undated.size();
	}

	int TMTaskList::getArchivedSize() {
		return _archived.size();
	}

	std::vector<TMTask> TMTaskList::getDated() {
		return _dated;
	}
	
	std::vector<TMTask> TMTaskList::getUndated() {
		return _undated;
	}
	
	std::vector<TMTask> TMTaskList::getArchived() {
		return _archived;
	}

	int TMTaskList::generateUniqueBatchNum() {
		std::vector<TMTask>::iterator iter;
		int i;
		for (i = 1; !isUniqueBatchNum(i); ++i) {
			}

		return i;
	}


	//BASIC FUNCTIONS//
	void TMTaskList::addTask (TMTask &task) {
		TaskType type = task.getTaskType();
		std::string outcome;
		switch (type) {
			
		case WithStartDateTime:
			_dated.push_back(task);
			chronoSort();
			break;

		case WithEndDateTime:
			_dated.push_back(task);
			chronoSort();
			break;
		
		case WithPeriod:
			if (int(_dated.size()) != 0 && hasClash(task)) {
				setClashes(task, _dated.begin());
				task.setAsClashed();
			} 
			_dated.push_back(task);
			chronoSort();
			break;

		case Undated: 
			_undated.push_back(task);
			alphaSort();
			break;

		case Invalid:
			break;
		}

		return;
	}

	
	void  TMTaskList::updateTask(int positionIndex, TMTask &alteredTask) {
		removeTask(positionIndex);
		addTask(alteredTask);
		return;
	}

	void  TMTaskList::removeTask(int positionIndex) {	
		
		if (isInDated(positionIndex)) {
			TMTask deleteTask = getTaskFromPositionIndex(positionIndex);
			_dated.erase(_dated.begin() + positionIndex - 1);
			if (deleteTask.getTaskType() == TaskType::WithPeriod) {
				updateClashes(deleteTask);
			}
			return;

		} else if (isInUndated(positionIndex)) {
			int floatingTaskNumber = positionIndex - _dated.size();
			_undated.erase(_undated.begin() + floatingTaskNumber - 1);
			return;

		} else if (isInArchived(positionIndex)) {
			int archivedTaskNumber = positionIndex - _dated.size() - _undated.size();
			_archived.erase(_archived.begin() + archivedTaskNumber - 1);
			return;
		}

		return;
	}
	
	void  TMTaskList::archiveOneTask(int positionIndex) {
		TMTask &task = getTaskFromPositionIndex(positionIndex);
		task.setAsCompleted();
		_archived.push_back(task);
		removeTask(positionIndex);
		return;
	}

	void TMTaskList::chronoSort() {
		std::vector<TMTask>::iterator iter;
		for (iter = _dated.begin(); iter != _dated.end(); ++iter) {
			std::iter_swap(iter, findEarliestTaskIter(iter));
		}
	}

	void TMTaskList::alphaSort() {
		std::vector<TMTask>::iterator iter;
		for (iter = _undated.begin(); iter != _undated.end(); ++iter) {
			std::iter_swap(iter, findSmallestAlphaTaskIter(iter));
		}
	}	

	std::vector<int> TMTaskList::keywordSearch(std::string keyword) {
		std::string lowerKeyword = toLower(keyword);
		
		std::vector<std::string> taskDescInLower;
		std::vector<TMTask>::iterator iter;
		std::vector<int> searchResults;
		int posIndexCounter = 1;

		for (iter = _dated.begin(); iter != _dated.end(); ++iter) {
			taskDescInLower.push_back(toLower((*iter).getTaskDescription()));
		}
		for (iter = _undated.begin(); iter != _undated.end(); ++iter) {
			taskDescInLower.push_back(toLower((*iter).getTaskDescription()));
		}
		for (iter = _archived.begin(); iter != _archived.end(); ++iter) {
			taskDescInLower.push_back(toLower((*iter).getTaskDescription()));
		}

		std::vector<std::string>::iterator iterForLower;
		for (iterForLower = taskDescInLower.begin(); iterForLower != taskDescInLower.end(); ++iterForLower) {
			std::string searchLine = *iterForLower;
			if ( std::search(searchLine.begin(), searchLine.end(), lowerKeyword.begin(), lowerKeyword.end()) != searchLine.end() ) {
				searchResults.push_back(posIndexCounter);
			}
			posIndexCounter++;
		}
	
		return searchResults;
	}



	//EXPORT AND IMPORT FUNCTIONS
	
	bool TMTaskList::isFoundInLine(std::string text, std::string line) {
		bool result = (std::search(line.begin(), line.end(), text.begin(), text.end()) != line.end());
		std::cout << "RESULT: " << result << std::endl;
		return std::search(line.begin(), line.end(), text.begin(), text.end()) != line.end();
	}
	
	bool TMTaskList::isValidDirectory(const char* directory) {
		DWORD attributes = GetFileAttributesA(directory);
		if (attributes == INVALID_FILE_ATTRIBUTES) {
			return false;
		}
		
		return (attributes & FILE_ATTRIBUTE_DIRECTORY);
	}

	void TMTaskList::loadOrCreateFile() {
		setDefaultFileName();

		if (std::ifstream(DEFAULT_REFERENCE_FILENAME)) {
			std::ifstream directoryReference(DEFAULT_REFERENCE_FILENAME);
			std::string directoryName;
			getline(directoryReference, directoryName);
			std::string pathName = directoryName + "\\" + _fileName;
			if (std::ifstream(pathName)) {
				setDirectoryName(directoryName);
				loadFromFile();
			} else {
				setDirectoryName(getExePath());
				createFile();
			}
		} else {
			setDirectoryName(getExePath());
			createFile();
			leaveReferenceUponExit();
		}
		return;
	}

	void TMTaskList::setDirectoryName(std::string directory) {
		_directoryName = directory;
	}

	void TMTaskList::setDefaultFileName() {
		boost::gregorian::date dateToday =  boost::gregorian::day_clock::local_day();
		std::locale facet(std::locale::classic(), new boost::gregorian::date_facet("%d %b %Y"));
		std::ostringstream stream;
		stream.imbue(facet);
		std::string  strDateToday;
		stream << dateToday;
		strDateToday = stream.str();
		std::string year, defaultFileName;
		
		year = strDateToday.substr(strDateToday.size()-4, 4);
		defaultFileName = "TM " + year + " Schedule.txt"; 
		_fileName = defaultFileName; 
	}

	std::string TMTaskList::getDirectoryName() {
		return _directoryName;
	}

	std::string TMTaskList::getFileName() {
		return _fileName;
	}

	std::string TMTaskList::getExeFileName() {
		char buffer[MAX_PATH];
		GetModuleFileName( NULL, buffer, MAX_PATH );
		return std::string(buffer);
	}

	std::string TMTaskList::getExePath() {
		std::string exeDirectoryAndFileName = getExeFileName();
		return exeDirectoryAndFileName.substr(0, exeDirectoryAndFileName.find_last_of( "\\/" ));
	}

	void TMTaskList::writeToFile() {
		std::ofstream outFile;
		std::vector<TMTask>::iterator iter;
		std::string fileDirectory = _directoryName + "\\" + _fileName;
		outFile.open(fileDirectory);
	
		outFile << DATED_HEADER  << _dated.size() << "\n";
		outFile << DATED_TASK_DISPLAY_FORMAT << "\n";
		for (iter = _dated.begin(); iter != _dated.end(); ++iter) {
			outFile << iter->getTaskTypeAsString() <<
			" "	<< iter->getTaskDescription() << " ||" 
			" " << iter->getTaskTime().getStartDate() << 
			" " << iter->getTaskTime().getStartTime() << 
			" " << iter->getTaskTime().getEndDate() <<
			" " << iter->getTaskTime().getEndTime() << 
			" " << iter->isCompleted() << 
			" " << iter->isClashed() << 
			" " << iter->isConfirmed() << 
			" " << iter->getUnconfirmedBatchNumber() << "\n";
		}

		//outFile << "\n";
	
		outFile << UNDATED_HEADER << _undated.size() << "\n";
		outFile << UNDATED_TASK_DISPLAY_FORMAT << "\n";
		for (iter = _undated.begin(); iter != _undated.end(); ++iter) {
			outFile << iter->getTaskTypeAsString() << 
				" "	<< iter->getTaskDescription() << " ||" 
				" " << iter->isCompleted() << "\n";
		}

		//outFile << "\n";

		outFile << ARCHIVED_HEADER << _archived.size() << "\n";
		for (iter = _archived.begin(); iter != _archived.end(); iter++) {
			
			if (iter->getTaskType() != TaskType::Undated) {
				outFile << iter->getTaskTypeAsString() <<
				" "	<< iter->getTaskDescription() << " ||" 
				" " << iter->getTaskTime().getStartDate() << 
				" " << iter->getTaskTime().getStartTime() << 
				" " << iter->getTaskTime().getEndDate() <<
				" " << iter->getTaskTime().getEndTime() << 
				" " << iter->isCompleted() << 
				" " << iter->isClashed() << 
				" " << iter->isConfirmed() << 
				" " << iter->getUnconfirmedBatchNumber() << "\n";
			} else {
				outFile << iter->getTaskTypeAsString() << 
				" "	<< iter->getTaskDescription() << " ||" 
				" " << iter->isCompleted() << "\n";
			}
		}

		outFile.close();
	}

	void TMTaskList::createFile() {
		std::ofstream outFile;
		outFile.open(_fileName);
		writeToFile();
		outFile.close();
	}

	void TMTaskList::loadFromFile() {
		std::string pathName = _directoryName + "\\" + _fileName;
		std::ifstream contentReference(pathName);
		std::vector<std::string> linesFromFile;
		std::string line;


		while (getline(contentReference, line)) {
			if (line != "\n") {
				linesFromFile.push_back(line);
			}
		}
		
		contentReference.close();

		std::vector<std::string>::iterator iter;
		FormatConverter* converter = FormatConverter::getInstance();

		

		//Dated tasks
		iter = linesFromFile.begin() + 2;	//Skips first two irrelevant lines in the text file.
		while (!isFoundInLine(UNDATED_HEADER, *iter)) {
			TMTask task = converter->convertStringToTMTask(*iter);
			addTask(task);
			iter++;
		}

		//Undated tasks
		iter = iter + 2;
		while (!isFoundInLine(ARCHIVED_HEADER, *iter)) {
			TMTask task = converter->convertStringToTMTask(*iter);
			addTask(task);
			iter++;
		}


		//Completed tasks
		iter++;
		while (iter != linesFromFile.end()) {
			TMTask task = converter->convertStringToTMTask(*iter);
			_archived.push_back(task);
			iter++;
		}

		return;
	} 

	void TMTaskList::leaveReferenceUponExit() {
		std::ofstream outFile;
		outFile.open(DEFAULT_REFERENCE_FILENAME);
		outFile << _directoryName << '\n';
		outFile << USER_INFO_TIMEMASTER_FILE << '\n';
		outFile.close();
		}


	
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMTaskList.cpp





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMTaskList.h
	 */

#ifndef TMTASKLIST_H
#define TMTASKLIST_H

#include <fstream>
#include <vector>
#include <algorithm>
#include <string>
#include <iomanip>
#include <Windows.h>
#include <boost\date_time.hpp>

#include "TMDateTime.h"
#include "TMTask.h"
#include "FormatConverter.h"


class TMTaskList{
private:
	
	//Contains all the incompleted dated tasks for the current year
	std::vector<TMTask> _dated; 
	
	//Contains all the incompleted undated tasks for the current year
	std::vector<TMTask> _undated; 

	//Contains all the completed dated and undated tasks for the current year
	std::vector<TMTask> _archived;

	//A temporary container which stores tasks that clashes with a task of interest
	std::vector<TMTask> _clashes;
	
	//File name
	std::string _fileName;

	//Directory name
	std::string _directoryName;

public:
	TMTaskList();

	//LOGIC FUNCTIONS//
	//Compares 2 tasks, returns true if both tasks have similar attributes.
	bool areEquivalent(TMTask task1, TMTask task2); 

	//Checks if the task to be added has clash with current tasks in tasklist.
	bool hasClash(TMTask task);

	//Precondition: task1 starts before task2
	bool isTwoClash(TMTask task1, TMTask task2);

	//Postcondition: Returns true if task starts before time
	bool startsBeforeTime(TMTask task, TMDateTime time);

	//Postcondition: Returns true if task ends before time
	bool endsBeforeTime(TMTask task, TMDateTime time);

	//Postcondition: Returns true if time1 is before time2, returning false if time1 is after or equals to time2
	bool isBefore(TMDateTime time1, TMDateTime time2);

	bool areEquivalentDateTime(TMDateTime time1, TMDateTime time2);
 
	bool isValidPositionIndex(int positionIndex);

	bool isInDated(int positionIndex);

	bool isInUndated(int positionIndex);

	bool isInArchived(int positionIndex);

	bool isUniqueBatchNum(int i);

	
	//Assupmtion: task to be added to taskList is yet to be added
	//Set the clash status of tasks which clashes with the task to be added 
	//Adds tasks which clashes with task into _clashes vector, with the targeted search region specified by iterator beginFrom,
	//which is an iterator of the vector _dated
	void setClashes(TMTask task, std::vector<TMTask>::iterator beginFrom);

	//Updates the clash status of current tasks that clashes with the task to be removed or archived.
	//Remaining tasks which clashes with each other after removal of involved task will have their clash status set as clashed.
	void updateClashes(TMTask deleteTask);

	//Returns the iterator of the earliest task in the unsorted tasklist
	std::vector<TMTask>::iterator findEarliestTaskIter(std::vector<TMTask>::iterator unsortedStart);

	//Returns the iterator of the task with description containing the earliest alphabet in the unsorted tasklist
	std::vector<TMTask>::iterator findSmallestAlphaTaskIter(std::vector<TMTask>::iterator unsortedStart);
	
	//Postcondition: Returns a string which consists of only lowercase letters
	std::string toLower(std::string toBeConverted);

	//Returns the positionIndexes of tasks which unconfirmed batch number is i in a vector
	std::vector<int> searchUnconfirmedBatchNum(int i);

	
	

	//GETTER FUNCTIONS//
	//Postcondition: Returns 0 if the position index is not found
	int getPositionIndexFromTask(TMTask task);
	TMTask getTaskFromPositionIndex(int positionIndex);
	int getDatedSize();
	int getUndatedSize();
	int getArchivedSize();
	int getClashesSize();
	std::vector<TMTask> getDated();
	std::vector<TMTask> getUndated();
	std::vector<TMTask> getArchived();
	
	//Returns a unique unconfirmed batch number such that tasks that have been blocked at the same instance share the same unconfirmed batch number
	int generateUniqueBatchNum();


	//BASIC FUNCTIONS//
	void addTask(TMTask &task);
	
	//Removes the outdated task from taskList and adds alteredTask
	void updateTask(int positionIndex, TMTask &alteredTask);
	
	void removeTask(int positionIndex);
	
	//Carried out when the task is marked as completed by the user
	void archiveOneTask(int positionIndex);
	
	//Sorts tasks in tasklist in chronological order according to their start dates
	//Precondition: _dated vector not empty
	void chronoSort();
	
	//Sorts tasks in alphabetical order of their description
	void alphaSort();
	
	//Return the position indexes of tasks which match the keyword
	//Note that the search is not case sensitive.
	std::vector<int> keywordSearch(std::string keyword);

	//EXPORT AND IMPORT FUNCTIONS//
	bool isFoundInLine(std::string text, std::string line);
	bool isValidDirectory(const char* directory);
	void loadOrCreateFile();
	
	void setDirectoryName(std::string directory);
	void setDefaultFileName();
	std::string getDirectoryName();
	std::string getFileName();
	std::string getExeFileName();
	std::string getExePath();

	void writeToFile();
	void createFile();
	void loadFromFile();
	void leaveReferenceUponExit();

};

#endif

	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMTaskList.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMTaskListStates.cpp
	 */

#include "TMTaskListStates.h"

TMTaskListStates* TMTaskListStates::theOne;

TMTaskListStates* TMTaskListStates::getInstance() {
	if (theOne == NULL) {
		theOne = new TMTaskListStates();
	}
	return theOne;
}

TMTaskListStates::TMTaskListStates() {
	TMTaskList taskList;
	taskList.loadOrCreateFile();
	addNewState(taskList);
}

void TMTaskListStates::addNewState(TMTaskList taskList) {
	if (!_states.empty() && _currentState != _states.end()-1) {
		_states.erase(_currentState + 1, _states.end());
	} 

	_states.push_back(taskList);
	_currentState = _states.end()-1;
}

bool TMTaskListStates::regressCurrentState() {
	if (_currentState != _states.begin()) {
		--_currentState;
		return true;
	} else {
		return false;
	}
}

bool TMTaskListStates::progressCurrentState() {
	if (_currentState != _states.end()-1) {
		++_currentState;
		return true;
	} else {
		return false;
	}
}

TMTaskList  TMTaskListStates::getCurrentTaskList() {
	return *_currentState;
}
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMTaskListStates.cpp





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMTaskListStates.h
	 */

#ifndef TMTASKLISTSTATES_H
#define TMTASKLISTSTATES_H

#include "TMTaskList.h"

class TMTaskListStates {

private: 
	std::vector<TMTaskList> _states;
	std::vector<TMTaskList>::iterator _currentState;
	static TMTaskListStates *theOne;
	TMTaskListStates();

public:
	static TMTaskListStates* getInstance();
	void addNewState(TMTaskList taskList);
	
	//Returns true if current state is able to regress and false otherwise
	bool regressCurrentState();

	//Returns true if current state is able to progress and false otherwise
	bool progressCurrentState();

	TMTaskList getCurrentTaskList();
	

};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMTaskListStates.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMUncompleteTasks.h
	 */

#ifndef TMUNCOMPLETETASKS_H
#define TMUNCOMPLETETASKS_H

#include "TMCommand.h"

class TMUncompleteTasks: public TMCommand { 
	
public:
	void execute() {
		TMParser *parser = TMParser::getInstance(); 
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		
		TMTaskList taskList = taskListStates->getCurrentTaskList();
		
		std::vector<int> uncompleteIndexes = parser->parseTaskPositionNo();
		std::vector<int>::iterator intIter;
		std::vector<TMTask> reAddTasks;
		std::vector<TMTask>::iterator taskIter;
		
		std::ostringstream ossValid, ossInvalid;

		if (hasRepeatedIndexes(uncompleteIndexes)) {
			handleRepeatedIndexes();
			return;
		}
			
		for (intIter = uncompleteIndexes.begin(); intIter != uncompleteIndexes.end(); ) {
			
			if (!taskList.isValidPositionIndex(*intIter)) {
				ossInvalid << *intIter << " ";
				intIter = uncompleteIndexes.erase(intIter);
			} else {
				TMTask task = taskList.getTaskFromPositionIndex(*intIter);
				if (!task.isCompleted()) {
					ossInvalid << *intIter << " ";
					intIter = uncompleteIndexes.erase(intIter);
				} else {
					++intIter;
				}
			}
		}

		for (intIter = uncompleteIndexes.begin(); intIter != uncompleteIndexes.end(); ++intIter) {
			TMTask task = taskList.getTaskFromPositionIndex(*intIter);
			taskList.removeTask(*intIter);
			updatePositionIndexes(uncompleteIndexes, *intIter);			
			task.setAsIncompleted();
			reAddTasks.push_back(task);
		}
		
			//Re-add tasks to taskList
		for (taskIter = reAddTasks.begin(); taskIter != reAddTasks.end(); ++taskIter) {
			TMTask task = *taskIter;
			taskList.addTask(task);
			int positionIndex = taskList.getPositionIndexFromTask(task);
			positionIndexes.push_back(positionIndex);
		}

		if (hasValidIndexes(int (reAddTasks.size()))) {
			ossValid << reAddTasks.size() << UNCOMPLETE_SUCCESS << '\n'; 
		}

		if (hasInvalidIndexes(ossInvalid.str())) {
			ossInvalid << STATUS_DISPLAY_INVALID_INDEXES;
		}
		outcome = ossValid.str() + ossInvalid.str();
		taskListStates->addNewState(taskList);
	}
};
#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMUncompleteTasks.h





	/**
	 * origin: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMUndo.h
	 */

#ifndef TMUNDO_H
#define TMUNDO_H

#include "TMCommand.h"


class TMUndo: public TMCommand {

public:
	void execute() {
		TMTaskListStates *taskListStates = TMTaskListStates::getInstance();
		if (taskListStates->regressCurrentState()) {
			outcome = UNDO_SUCCESS;
		} else {
			outcome = UNDO_FAILURE;
		} 
	}
};

#endif
	// End of segment: C:\Users\Wei Ern\Documents\Visual Studio 2012\Projects\TimeMaster\Library\TMUndo.h





